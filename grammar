# grammar for anole
# http://www.jusot.com/anole/grammar/

# start symbols for the grammar:
#       stmt is a single interactive statemnet;
#       stmts is a module or sequence of commands read from an input file;

%token At;      // @
%token Atat;    // @@

%token Use;     // use
%token From;    // from
%token If;      // if
%token Elif;    // elif
%token Else;    // else
%token While;   // while
%token Do;      // do
%token Foreach; // foreach
%token As;      // as
%token Break;   // break
%token Continue;// continue
%token Return;  // return
%token Match;   // match
%token Delay;   // delay

%token New;     // new
%token Enum;    // enum

%token None;    // none
%token True;    // true
%token False;   // false

%token Identifier; // [a-za-z_][a-za-z0-9_]*
%token Integer;    // [0-9]+
%token Double;     // [0-9]+\.[0-9]*
%token String;     // "[^"\n]"

%token BLS;       // <<
%token BRH;       // >>
%token And;       // and
%token Or;        // or
%token Not;       // not !
%token Is;        // is
%token CEQ;       // =
%token CNE;       // !=
%token CLT;       // <
%token CLE;       // <=
%token CGT;       // >
%token CGE;       // >=
%token Ret;       // =>
%token Add;       // +
%token Sub;       // -
%token Mul;       // *
%token Div;       // /
%token Mod;       // %
%token Colon;     // :
%token Semicolon; // ;
%token Dot;       // .
%token Comma;     // ,
%token LParen;    // (
%token RParen;    // )
%token LBracket;  // [
%token RBracket;  // ]
%token LBrace;    // {
%token RBrace;    // }
%token Ques;      // ?

%%

%start program;

program
    : stmts
    ;

stmts
    : %empty
    | stmt stmts
    | stmt Semicolon stmts
    ;

stmt
    : declaration
    | class_decl
    | if_else
    | while_stmt
    | do_while_stmt
    | foreach_stmt
    | expr
    | return_stmt
    | use_stmt
    | Continue
    | Break
    ;

declaration
    : At ident
    | At ident Colon delay_expr
    | At ident LParen decl_args RParen lambda_decl_tail
    ;

block
    : LBrace stmts RBrace
    | Comma stmt
    ;

ident
    : Identifier
    ;

numeric
    : Integer
    | Double
    ;

none
    : None
    ;

boolean
    : True
    | False
    ;

string
    : String
    ;

expr
    : expr0 Ques expr Comma expr
    | expr0
    ;

expr0
    : expr1 Or expr0
    | expr1
    ;

expr1
    : expr2 And expr1
    | expr2
    ;

expr2
    : expr3 CEQ expr2
    | expr3 CNE expr2
    | expr3 CLT expr2
    | expr3 CLE expr2
    | expr3 CGT expr2
    | expr3 CGE expr2
    | expr3
    ;

expr3
    : expr4 BLS expr3
    | expr4 BRH expr3
    | expr4
    ;

expr4
    : expr5 Add expr4
    | expr5 Sub expr4
    | expr5
    ;

expr5
    : expr6 Is  expr5
    | expr6 Mul expr5
    | expr6 Div expr5
    | expr6 Mod expr5
    | expr6
    ;

expr6
    : Not expr6
    | Sub expr6
    | term term_tail
    | term term_tail Colon delay_expr
    ;

term
    : ident
    | numeric
    | none
    | boolean
    | string
    | LParen expr RParen
    | lambda_expr
    | new_expr
    | match_expr
    | list_expr
    | enum_expr
    | dict_expr
    ;

term_tail
    : %empty
    | Dot ident term_tail
    | LParen call_args RParen term_tail
    | LBracket expr RBracket term_tail
    ;

call_args
    : %empty
    | delay_expr call_args_rest
    ;

call_args_rest
    : %empty
    | Comma delay_expr call_args_rest
    ;

delay_expr
    : expr
    | Delay expr
    ;

if_else
    : If expr block if_else_tail
    ;

if_else_tail
    : %empty
    | Elif block if_else_tail
    | Else block
    ;

while_stmt
    : While expr block
    ;

do_while_stmt
    : Do block While expr
    ;

foreach_stmt
    : Foreach expr block
    | Foreach expr As ident block
    ;

lambda_expr
    : At LParen decl_args RParen lambda_decl_tail
    ;

decl_args
    : %empty
    | ident decl_args_rest
    | ident Colon expr decl_args_rest
    ;

decl_args_rest
    : %empty
    | Comma ident decl_args_rest
    | Comma ident Colon expr decl_args_rest
    ;

lambda_decl_tail
    : Colon expr
    | block
    ;

class_decl
    : Atat ident LParen bases RParen block
    ;

bases:
    : %empty
    | ident bases_rest
    ;

bases_rest
    : %empty
    | Comma ident bases_rest
    ;

new_expr
    : New ident LParen call_args RParen
    ;

enum_expr
    : Enum LBrace enums RBrace
    ;

enums
    : %empty
    | ident enums
    | ident Colon Integer enums_rest
    ;

enums_rest
    : %empty
    | Comma ident enums_rest
    | Comma ident Colon Integer enums_rest
    ;

dict_expr
    : LBrace RBrace
    | LBrace expr Ret expr dict_rest RBrace
    ;

dict_rest
    : %empty
    | Comma expr Ret expr dict_rest
    ;

match_expr
    : Match expr LBrace RBrace match_tail
    | Match expr LBrace expr call_args_rest Ret expr match_rest RBrace match_tail
    ;

match_rest
    : %empty
    | Comma expr call_args_rest Ret expr match_rest
    ;

match_tail
    : %empty
    | Else expr
    ;

list_expr
    : LBracket call_args RBracket
    ;

return_stmt
    : Return expr
    ;

alias_ident
    : ident
    | ident As ident
    ;

alias_idents
    : alias_ident
    | alias_ident Comma alias_idents
    ;

use_stmt
    : Use alias_idents
    | Use alias_idents From ident
    | Use Mul From ident
    ;
