# grammar for ice
# http://www.jusot.com/ice/grammar/

# start symbols for the grammar:
#       stmt is a single interactive statemnet;
#       stmts is a module or sequence of commands read from an input file;

%token At;      // @
%token Atat;    // @@

%token Using;   // using
%token If;      // if
%token Elif;    // elif
%token Else;    // else
%token While;   // while
%token Do;      // do
%token For;     // for
%token To;      // to
%token Foreach; // foreach
%token As;      // as
%token Break;   // break
%token Continue;// continue
%token Return;  // return
%token Match;   // match

%token New;     // new

%token None;    // none
%token True;    // true
%token False;   // false

%token Identifier; // [a-za-z_][a-za-z0-9_]*
%token Integer;    // [0-9]+
%token Double;     // [0-9]+\.[0-9]*
%token String;     // "[^"\n]"

%token BLS;       // <<
%token BRH;       // >>
%token And;       // and
%token Or;        // or
%token Not;       // not !
%token CEQ;       // =
%token CNE;       // !=
%token CLT;       // <
%token CLE;       // <=
%token CGT;       // >
%token CGE;       // >=
%token Ret;       // =>
%token Add;       // +
%token Sub;       // -
%token Mul;       // *
%token Div;       // /
%token Mod;       // %
%token Assign;    // %
%token Dot;       // .
%token Comma;     // ,
%token LParen;    // (
%token RParen;    // )
%token LBracket;  // [
%token RBracket;  // ]
%token LBrace;    // {
%token RBrace;    // }

%%

%start program;

program
    : stmts
    ;

stmts
    : %empty
    | stmt stmts
    ;

stmt
    : assignment
    | class_decl
    | if_else
    | while_stmt
    | do_while_stmt
    | for_stmt
    | foreach_stmt
    | expr
    | Return expr
    | Using ident
    | Continue
    | Break
    ;

assignment
    : At ident
    | At ident Assign expr
    | At ident LParen decl_args RParen lambda_decl_tail
    ;

block
    : LBrace stmts RBrace
    ;

ident
    : Identifier
    ;

numeric
    : Integer
    | Double
    ;

none
    : None
    ;

boolean
    : True
    | False
    ;

string
    : String
    ;

expr
    : expr1 Assign expr1
    | expr1
    ;

expr1
    : expr2 Or expr2
    | expr2 And expr2
    | expr2
    ;

expr2
    : expr3 CEQ expr3
    | expr3 CNE expr3
    | expr3 CLT expr3
    | expr3 CLE expr3
    | expr3 CGT expr3
    | expr3 CGE expr3
    | expr4
    ;

expr3
    : expr4 BLS expr4
    | expr4 BRH expr4
    | expr4
    ;

expr4
    : expr5 Add expr5
    | expr5 Sub expr5
    | expr5
    ;

expr5
    : expr6 Mul expr6
    | expr6 Div expr6
    | expr6 Mod expr6
    | expr6
    ;

expr6
    : Not expr6
    | Sub expr6
    | term term_tail
    ;

term
    : ident
    | numeric
    | none
    | boolean
    | string
    | LParen expr RParen
    | lambda_expr
    | new_expr
    | match_expr
    | list_expr
    | enum_expr
    | dict_expr
    ;

term_tail
    : %empty
    | Dot ident term_tail
    | LParen call_args RParen term_tail
    | LBracket expr RBracket term_tail
    ;

call_args
    : %empty
    | expr call_args_rest
    ;

call_args_rest
    : %empty
    | Comma expr call_args_rest
    ;

if_else
    : If expr block if_else_tail
    ;

if_else_tail
    : %empty
    | Elif block if_else_tail
    | Else block
    ;

while_stmt
    : While expr block
    ;

do_while_stmt
    : Do block While expr
    ;

for_stmt
    : For expr To expr As ident block
    | For expr To expr block
    ;

foreach_stmt
    : Foreach expr As ident block
    ;

lambda_expr
    : At LParen decl_args RParen lambda_decl_tail
    ;

decl_args
    : %empty
    | ident decl_args_rest
    | ident Assign expr decl_args_rest
    ;

decl_args_rest
    : %empty
    | Comma ident decl_args_rest
    | Comma ident Assign expr decl_args_rest
    ;

lambda_decl_tail
    : Assign expr
    | block
    ;

class_decl
    : Atat ident LParen bases RParen block
    ;

bases:
    : %empty
    | ident bases_rest
    ;

bases_rest
    : %empty
    | Comma ident bases_rest
    ;

new_expr
    : New ident LParen call_args RParen
    ;

enum_expr
    : LBrace ident enum_rest RBrace
    ;

enum_rest
    : %empty
    | Comma ident enum_rest
    ;

dict_expr
    : LBrace RBrace
    | LBrace expr Assign expr dict_rest RBrace
    ;

dict_rest
    : %empty
    | Comma expr Assign expr dict_rest
    ;

match_expr
    : Match expr LBrace RBrace match_tail
    | Match expr LBrace expr call_args_rest Ret expr match_rest RBrace match_tail
    ;

match_rest
    : %empty
    | Comma expr call_args_rest Ret expr match_rest
    ;

match_tail
    : %empty
    | Else expr
    ;

list_expr
    : LBracket call_args RBracket
    ;
